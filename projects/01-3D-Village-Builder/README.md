# Project 01: Basic 3D Village Builder (Single HTML File)

This project showcases an attempt to generate a basic 3D village building game entirely within a single HTML file, using inline JavaScript and the Three.js library, based on a concise prompt given to a Large Language Model (LLM).

## Original Prompt Essence

The core request to the LLM was:

"Build within a singular HTML file with inline javascript, a basic 3d village building game. The game should allow users to place, move, and delete blocks:

Core features:
*   The buildings should all be rendered with a low poly simple style
*   Utilize Three D rendering with any library of your choosing like for example Three.js
*   Implement a grid-snapping system for placing the buildings
*   Ensure proper object collision so buildings can only be placed when there is not a building already there
*   Make the code work in a modern web browser without any additional dependencies
*   Include multiple building styles, house, duplex, park, and more
*   Optimize performance to handle a complex village

Implement rotation controls for the user and a selectable menu to place the buildings"

*(Note: The actual interaction might have involved iterative refinement, but this captures the initial goal.)*

## LLM Output

The file `village_builder.html` in this directory is the primary output generated by the LLM, with some iterative debugging and refinement guided by user feedback (simulating a conversation with the LLM).

## Key Features Implemented by the LLM

*   **Single HTML File Structure:** The entire game, including 3D rendering logic, game mechanics, and UI, is contained within one HTML file.
*   **Three.js Integration:** The LLM successfully chose and integrated Three.js for 3D rendering.
    *   It utilized ES Module imports via an import map for Three.js and OrbitControls, making it work directly in modern browsers from CDNs.
*   **3D Scene Setup:** Includes camera, lighting (ambient and directional with shadows), a ground plane, and a grid helper.
*   **Building Primitives:**
    *   Defined several building types (`house`, `duplex`, `park`, `skyscraper`, `factory`) with distinct low-poly geometries.
    *   Building parts are created as `THREE.Mesh` objects and positioned within their definition to ensure their base is at y=0 for easy placement.
*   **Placement System:**
    *   Grid-snapping for building placement.
    *   Visual "ghost" building showing where the selected structure will be placed.
    *   Rotation of the ghost building (`R` key) before placement.
*   **Collision Detection:**
    *   Grid-based Axis-Aligned Bounding Box (AABB) style collision checking.
    *   Prevents placing buildings on top of existing ones.
    *   Ghost building changes color (red) if placement is invalid.
*   **Object Interaction:**
    *   **Placement Mode:** Select building type from a dropdown, rotate, and click to place.
    *   **Move Mode:** Click to select an existing building, then click a new valid location to move it.
    *   **Delete Mode:** Click an existing building to remove it.
    *   Selected buildings are highlighted.
    *   Keyboard shortcuts for rotation (`R`), deselect/cancel (`Esc`), and delete (`Delete`/`Backspace`).
*   **User Interface (HTML/CSS):**
    *   A simple overlay UI for selecting tools (Place, Move, Delete) and building types.
    *   An info panel at the bottom displaying current tool, selected building, and hints.
*   **Camera Controls:** `OrbitControls` for navigating the 3D scene.

## Observations & LLM Performance

*   **Initial Scaffolding:** The LLM was quite effective at setting up the basic Three.js scene, HTML structure, and UI elements.
*   **Core Logic Implementation:** It managed to implement the core game loop for placement, selection, and the concept of a "ghost" building.
*   **Modularity within a Single File:** Despite being a single file, the LLM attempted to organize code into functions and distinct sections (setup, game state, UI, event handlers, etc.).
*   **Collision Logic:** The initial collision logic often needed refinement. The concept was understood, but precise implementation of footprint checking, especially with rotation and different building sizes, required several iterations.
*   **Library Usage (Import Maps):** After initial struggles with CDN script tags and ES modules, guiding the LLM towards using `importmap` was a key step for a cleaner, modern JavaScript approach.
*   **Geometry and Positioning:** Defining building geometries such that their logical base was consistently at y=0 for easier world placement was an area that benefited from explicit guidance during iterative prompting.
*   **Error Handling & Debugging:** The LLM generated code that often had subtle bugs (e.g., incorrect variable scope, off-by-one errors in grid calculations, issues with material handling for selected/ghost states). The "user" (prompter) had to point out console errors or visual discrepancies to guide the LLM towards fixes.
*   **Performance "Optimization":** The prompt asked for optimization. The LLM kept geometries simple and reused materials via a cache, which are good basic steps. For a *truly* complex village, more advanced techniques like instancing would be necessary, which was likely beyond the scope of the initial "minimal input" generation.

## Challenges and Iterations

*   **Module Resolution:** The most significant initial hurdle was getting Three.js and its addons to load correctly as modules within a single HTML file that aims for no *build-step* dependencies. The `importmap` solution was crucial.
*   **Collision Accuracy:** Ensuring collision detection worked correctly for all building sizes and rotations took several back-and-forth "debugging" interactions.
*   **State Management:** Managing states like `currentTool`, `selectedBuilding`, and `ghostBuilding` and ensuring they interacted correctly (e.g., removing a placement ghost when a building is selected for moving) required careful prompting.
*   **Material Handling:** Consistently applying and reverting materials for normal, ghost, selected, and collision states across multiple building parts.

## Conclusion

This project demonstrates that an LLM can generate a surprisingly functional and complex application like a basic 3D game from a relatively high-level description, even within the constraint of a single file. However, achieving a polished and bug-free result typically requires an iterative process of prompting, providing feedback on errors or undesired behavior, and guiding the LLM towards correct implementations. The LLM acts as an incredibly fast (but sometimes flawed) junior developer that needs good direction.

This experiment highlights the LLM's strength in boilerplate reduction, initial feature implementation, and understanding of common programming patterns, while also showing the current need for human oversight in debugging, architectural refinement, and handling nuanced logic.